let
  data Unit | Unit_match where
    Unit : Unit
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  !unitval : unit = ()
in
\(ds : (\a -> data) data) ->
  Tuple2_match
    {integer}
    {list data}
    ((let
         b = list data
       in
       \(tup : pair integer b) ->
         Tuple2
           {integer}
           {b}
           (fstPair {integer} {b} tup)
           (sndPair {integer} {b} tup))
       (unConstrData ds))
    {data}
    (\(ds : integer) (ds : list data) ->
       ifThenElse
         {all dead. data}
         (equalsInteger 0 ds)
         (/\dead -> headList {data} ds)
         (/\dead ->
            Tuple2_match
              {integer}
              {list data}
              ((let
                   b = list data
                 in
                 \(tup : pair integer b) ->
                   Tuple2
                     {integer}
                     {b}
                     (fstPair {integer} {b} tup)
                     (sndPair {integer} {b} tup))
                 (unConstrData ds))
              {data}
              (\(ds : integer) (ds : list data) ->
                 ifThenElse
                   {all dead. data}
                   (equalsInteger 1 ds)
                   (/\dead ->
                      constrData
                        0
                        (mkCons
                           {data}
                           (constrData 0 (mkNilData unitval))
                           (mkNilData unitval)))
                   (/\dead -> Unit_match (error {Unit}) {data} (error {data}))
                   {all dead. dead}))
         {all dead. dead})