let
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Unit | Unit_match where
    Unit : Unit
  !matchData' :
     all r.
       data ->
       (integer -> list data -> r) ->
       (list (pair data data) -> r) ->
       (list data -> r) ->
       (integer -> r) ->
       (bytestring -> r) ->
       r
    = /\r ->
        \(d : data)
         (constrCase : integer -> list data -> r)
         (mapCase : list (pair data data) -> r)
         (listCase : list data -> r)
         (iCase : integer -> r)
         (bCase : bytestring -> r) ->
          chooseData
            {Unit -> r}
            d
            (\(ds : Unit) ->
               let
                 !tup : pair integer (list data) = unConstrData d
               in
               constrCase
                 (fstPair {integer} {list data} tup)
                 (sndPair {integer} {list data} tup))
            (\(ds : Unit) -> mapCase (unMapData d))
            (\(ds : Unit) -> listCase (unListData d))
            (\(ds : Unit) -> iCase (unIData d))
            (\(ds : Unit) -> bCase (unBData d))
            Unit
  !`$dFromData` : (\a -> data -> Maybe a) integer
    = \(d : data) ->
        matchData'
          {Maybe integer}
          d
          (\(ds : integer) (ds : list data) -> Nothing {integer})
          (\(ds : list (pair data data)) -> Nothing {integer})
          (\(ds : list data) -> Nothing {integer})
          (\(i : integer) -> Just {integer} i)
          (\(ds : bytestring) -> Nothing {integer})
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
in
\(ds : data) ->
  matchData'
    {Maybe (Tuple2 integer integer)}
    ds
    (\(index : integer) (args : list data) ->
       ifThenElse
         {unit -> Maybe (Tuple2 integer integer)}
         (equalsInteger 0 index)
         (\(ds : unit) ->
            chooseList
              {data}
              {Unit -> Maybe (Tuple2 integer integer)}
              args
              (\(ds : Unit) -> Nothing {Tuple2 integer integer})
              (\(ds : Unit) ->
                 let
                   !arg : data = headList {data} args
                   !t : list data = tailList {data} args
                 in
                 chooseList
                   {data}
                   {Unit -> Maybe (Tuple2 integer integer)}
                   t
                   (\(ds : Unit) -> Nothing {Tuple2 integer integer})
                   (\(ds : Unit) ->
                      let
                        !arg : data = headList {data} t
                      in
                      (let
                          r = Maybe (Tuple2 integer integer)
                        in
                        \(l : list data)
                         (nilCase : r)
                         (consCase : data -> list data -> r) ->
                          chooseList
                            {data}
                            {Unit -> r}
                            l
                            (\(ds : Unit) -> nilCase)
                            (\(ds : Unit) ->
                               consCase (headList {data} l) (tailList {data} l))
                            Unit)
                        (tailList {data} t)
                        (Maybe_match
                           {integer}
                           (matchData'
                              {Maybe integer}
                              arg
                              (\(ds : integer) (ds : list data) ->
                                 Nothing {integer})
                              (\(ds : list (pair data data)) ->
                                 Nothing {integer})
                              (\(ds : list data) -> Nothing {integer})
                              (\(i : integer) -> Just {integer} i)
                              (\(ds : bytestring) -> Nothing {integer}))
                           {all dead. Maybe (Tuple2 integer integer)}
                           (\(ipv : integer) ->
                              /\dead ->
                                Maybe_match
                                  {integer}
                                  (`$dFromData` arg)
                                  {all dead. Maybe (Tuple2 integer integer)}
                                  (\(ipv : integer) ->
                                     /\dead ->
                                       Just
                                         {Tuple2 integer integer}
                                         (Tuple2 {integer} {integer} ipv ipv))
                                  (/\dead -> Nothing {Tuple2 integer integer})
                                  {all dead. dead})
                           (/\dead ->
                              let
                                !ds : Maybe integer = `$dFromData` arg
                              in
                              Nothing {Tuple2 integer integer})
                           {all dead. dead})
                        (\(ds : data) (ds : list data) ->
                           Nothing {Tuple2 integer integer}))
                   Unit)
              Unit)
         (\(ds : unit) -> Nothing {Tuple2 integer integer})
         ())
    (\(ds : list (pair data data)) -> Nothing {Tuple2 integer integer})
    (\(ds : list data) -> Nothing {Tuple2 integer integer})
    (\(ds : integer) -> Nothing {Tuple2 integer integer})
    (\(ds : bytestring) -> Nothing {Tuple2 integer integer})