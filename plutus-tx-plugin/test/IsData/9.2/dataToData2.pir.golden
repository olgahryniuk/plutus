let
  !unitval : unit = ()
  !fail : unit -> data
    = \(ds : unit) ->
        constrData
          0
          (mkCons {data} (constrData 0 (mkNilData unitval)) (mkNilData unitval))
  !`$bSecondC` : integer -> data
    = \(arg0_ : integer) ->
        constrData 1 (mkCons {data} (iData arg0_) (mkNilData unitval))
  data Unit | Unit_match where
    Unit : Unit
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
in
\(ds : (\a -> data) data) ->
  Tuple2_match
    {integer}
    {list data}
    ((let
         b = list data
       in
       \(tup : pair integer b) ->
         Tuple2
           {integer}
           {b}
           (fstPair {integer} {b} tup)
           (sndPair {integer} {b} tup))
       (unConstrData ds))
    {data}
    (\(ds : integer) (ds : list data) ->
       ifThenElse
         {all dead. data}
         (equalsInteger 0 ds)
         (/\dead ->
            let
              !b : integer = unIData (headList {data} (tailList {data} ds))
            in
            ifThenElse
              {all dead. data}
              (equalsData (headList {data} ds) (`$bSecondC` 42))
              (/\dead ->
                 ifThenElse
                   {all dead. data}
                   (equalsInteger 4 b)
                   (/\dead -> `$bSecondC` 147)
                   (/\dead -> fail ())
                   {all dead. dead})
              (/\dead -> fail ())
              {all dead. dead})
         (/\dead -> fail ())
         {all dead. dead})